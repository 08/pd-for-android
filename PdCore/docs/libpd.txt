Embedding Pure Data as a DSP library


1. Introduction

Fundamentally, the heart and soul of a DSP library is a rendering callback
that takes input samples and computes output samples.  Samples go in, magic
happens, samples come out.  That's signal processing in its purest form.
Unfortunately, this functionality is hard to find in Pure Data.  Bits and
pieces of it are spread across and mixed with various chunks of audio driver
code.  The main function of libpd is to liberate raw audio rendering from
audio drivers.

The second function of libpd is to allow for straightforward exchange of
control messages between Pure Data and client code.  libpd supports bang,
float, and symbol messages, as well as lists and typed messages.  (In other
words, pointer messages are the only messages that are not supported.)  Client
code sends messages to symbols in Pure Data, i.e., messages sent to Pd are
akin to those from message boxes of the form [;foo args(.  Client code
can subscribe to messages sent to symbols in Pd, i.e., adding a subscription
is akin to adding a receiver object [r foo] in Pd.


2. Initializing Pd

void libpd_init()
  Initialize libpd.

void libpd_clear_search_path()
  Clears the Pd search path, i.e., the path where Pd looks for abstractions
  and externals; clearing the search path is usually unnecessary because
  libpd_init() already clears the search path.

void libpd_add_to_search_path(const char *s)
  Add s to the Pd search path.

libpd only looks at the search path; the extra path is not used.


3. Rendering samples with Pd

int libpd_blocksize()
  Returns the block size of Pd (always 64).  Pd computes audio in ticks of 64
  samples per channel at a time.

int libpd_init_audio(int nInputs, int nOutputs,
                      int sampleRate, int ticksPerBuffer)
  Initialize audio rendering for the given number of input/output channels and
  sample rate.  In order to reduce the overhead of functions calls, libpd
  offers the option of processing more than one Pd tick per audio rendering
  call.  For minimal latency, choose one tick per buffer.  If you run into
  performance issues, try a larger number.  The return value is 0 if and only
  if the initialization of Pd succeeded.

int libpd_process_float(float *inBuf, float *outBuf)
  Reads on buffer of input samples from inBuf, processes them with Pd, and
  writes one buffer of output samples to outBuf.  The size of each buffer must
  be the product of the number of channels, the number of ticks per buffer,
  and the number of samples per tick.  (The number of samples per tick is the
  value returned by libpd_blocksize(), i.e., 64.)  Samples will be striped
  across buffers, i.e., if there are two input channels, then inBuf[0] is the
  first sample for the left channel, inBuf[1] is the first sample for the
  right channel, inBuf[2] is the second sample for the left channel, etc.
  The return value is 0 if and only if the call succeeded.

int libpd_process_double(double *inBuf, double *outBuf)
  Like libpd_process_float, but with double precision.

int libpd_process_short(short *inBuf, short *outBuf)
  Like libpd_process_float, but with short samples.  Float samples from Pd are
  converted to shorts by multiplying by 32767 and casting to short.  For
  efficiency reasons, this method does not clip the input.  If the float
  samples from Pd are outside the interval [-1, 1], then the converted short
  samples will be garbage.  If you expect samples outside of [-1, 1], you need
  to clip them yourself in your Pd patch.

int libpd_process_raw(float *inBuf, float *outBuf);
  Processes one Pd tick (regardless of the number of ticks per buffer supplied
  to libpd_init_audio) and copies the contents of the buffers directly to/from
  Pd, without striping.  In other words, the channels will be stacked rather
  than interlaced in inBuf and outBuf.

Note that libpd does not provide any timing functionality of its own.  It only
keeps track of time in terms of the number of Pd ticks that have been
processed.  Calling the process function at the right times is the
responsibility of the client.


4. Sending messages to Pd

Simple messages (bang, float, symbol) are sent to Pd with a single function
call.

int libpd_bang(const char *destination)
  Sends a bang to the destination, i.e., libpd_bang("foo") acts like
    [bang(
     |
    [s foo]
  The return value is 0 if and only if the call succeeded.

int libpd_float(const char *destination, float value)
  Sends a float to the destination.  The return value is 0 if and only if the
  call succeeded.
  
int libpd_symbol(const char *destination, const char *symbol)
  Sends a symbol to the destination.  The return value is 0 if and only if the
  call succeeded.

Compound (i.e., list or typed) messages are composed with a sequence of
function calls, using the following functions.

int libpd_start_message()
  Initiates the composition of a new list or typed message.  The return value
  is the largest possible number of arguments of a list or typed message that
  libpd supports (currently 32).  Note:  You have to start each list or typed
  message with libpd_start_message, but you don't have to finish it; it's okay
  to abandon a message without further cleanup.

void libpd_add_float(float value)
  Adds a float to the current message

void libpd_add_symbol(const char *symbol)
  Adds a symbol to the current message

int libpd_finish_list(const char *destination)
  Finishes a list message and sends it to the destination.  For instance, the
  behavior of [;foo 1 2 a( is achieved with
    libpd_start_message();
    libpd_add_float(1);
    libpd_add_float(2);
    libpd_add_symbol("a");
    libpd_finish_list("foo");
  The return value is 0 if and only if the call succeeded.
  
int libpd_finish_message(const char *destination, const char *symbol)
  Finishes a typed message and sends it to the destination, with the message
  name given by the symbol parameter.  For instance, the effect of [ ;pd dsp 1(
  is achieved with
    libpd_start_message();
    libpd_add_float(1);
    libpd_finish_message("pd", "dsp");
  The return value is 0 if and only if the call succeeded.  Note that libpd
  will let you send a typed message with as many as 32 parameters, but Pd
  itself will currently only handle typed messages with up to four parameters.


5. Receiving messages from Pd

In order to receive messages from Pd, client code needs register callback
functions and subscribe to messages sent to one ore more symbols.

void *libpd_bind(const char *symbol)
  Subscribe to messages sent to the given symbol.  The call libpd_bind("foo")
  adds an object to the patch that behaves much like [r foo], with the output
  being passed on to the various message hooks of libpd.  The return value is
  an opaque pointer to the new receiver object; save it in a variable if you
  want to be able to delete this object later.

int libpd_unbind(void *p)
  Deletes the object referred to by the pointer p.  This is mostly intended
  for removing receivers created by libpd_bind.


Once the client has subscribed to messages sent to one or more symbols, libpd
will try to call the corresponding message hooks.  A subscription to print
messages is automatic.  In order to receive print messages from Pd, client
code must define a function with the right signature and assign its pointer to
libpd_printhook.  In order to receive bangs, define the right kind of function
and assign it to libpd_banghook, etc.


t_libpd_printhook libpd_printhook
  Pointer to the function that is called when Pd wants to print; NULL by
  default.
typedef (*t_libpd_printhook)(const char *s)
  Signature for print hooks; the parameter s is the string to be printed.
  
t_libpd_banghook libpd_banghook
  Pointer to the function that is called when Pd wants to send a bang to
  libpd; NULL by default.  If the client has subscribed to the symbol foo with
  libpd_bind, then a bang sent with [s foo] will result in the function call
  libpd_banghoon"foo").
typedef (*t_libpd_banghook)(const char *source)
  Signature for bang hooks; the parameter source is the symbol that received
  the message.
  
t_libpd_floathook libpd_floathook
typede (*t_libpd_floathook)(const char *source, float value)

t_libpd_symbolhook libpd_symbolhook
typede (*t_libpd_symbolhook)(const char *source, const char *symbol)

t_libpd_listhook libpd_listhook
typedef (*t_libpd_listhook)(const char *source, int argc, t_atom *argv)
  Signature for list hooks.  The parameter argc is the length of the list, and
  the vector argv contains the list elements.  In order to evaluate to list
  for further processing, you probably want to use a loop like this one:
    int i;
    for (i = 0; i < argc; i++) {
      t_atom a = argv[i];
      if (a.a_type == A_FLOAT) {
        float x = a.a_w.w_float;
        // do something with the float x
      } else if (a.a_type == A_SYMBOL) {
        char *s = a.a_w.w_symbol->s_name;
        // do something with the C string s
      }
    }

t_libpd_messagehook libpd_messagehook
typedef (*t_libpd_messagehook)(const char *source, const char *symbol,
                int argc, t_atom *argv)
  Signature for typed message hooks; a message like [;foo bar 1 2 a b( will
  trigger a function call like libpd_messagehook("foo", "bar", 4, argv).


6. Using Pd in a threaded context

libpd is NOT thread-safe.  This was a deliberate design decision because
thread synchronization depends on the needs of the client code.  As a general
rule, if libpd is used in a threaded setting, then all functions of libpd must
be protected by locks.  Moreover, only one thread may assemble a compound
message at any given time, i.e., the lock must be acquired before the call to
libpd_start_message and released after the call to libpd_finish_list/message.
Failure to protect compound messages with locks will lead to obscure crashes.

Note:  While m_pd.h does offer global locking with sys_lock and sys_unlock,
but I don't see how to safely use them.  They use one non-reentrant global
lock, and it doesn't seem to be clear who is responsible for it.  In other
words, sys_lock and sys_unlock seem like a recipe for deadlocks.  I recommend
using your own private lock.


7. Using externals

When dynamically loaded libraries are available, libpd will automatically load
externals as needed, as long as the binaries are on the search path.  When
dynamic loading is not available, clients can have externals compiled into
them and initialize them by calling the setup function after calling the
libpd_init function.


8. Working with libpd

The Pd Java library illustrates how to work with libpd.  The JNI file z_jni.c
translates between C types and Java types.  The Java class PdBase.java imports
the functions of z_jni.c into Java and adds some higher-level functionality,
such as thread synchronization, compound messages with a single method call,
and bookkeeping for subscriptions to messages from Pd.  The interface
PdReceiver.java provides the basic functionality for receiving messages from
Pd.

In addition to the core functionality, it may be desirable to build some
utilities.  For instance, the core Java library only accepts one receiver for
Pd messages at a time.  The utility class PdDispatcher.class implements the
PdReceiver interface and manages a collection of handlers (instances of
PdListener.java) for messages sent to individual messages.

PdUtils.java is another utility class that provides some common messages:
* [;pd dsp 1( enables audio processing in Pd.  [;pd dsp 0( disables audio
  processing.
* [;pd open foo.pd /path/to/patch( opens a patch.
* [;pd menuclose pd-foo.pd( closes a patch.


9. Creating patches for use with libpd

Patches for use with libpd do not use any objects that are specific to libpd;
the custom message receiver objects for libpd are added implicitly and do not
explicitly occur in the patch.  Input and output of samples occur via adc~ and
dac~, as usual.  In order to test a patch for use with libpd, you can simply
use a second patch that communicates with the patch through the same control
messages (via send and receive objects) that libpd will use.

